### Chapter 12 - Indexes and Optimized Queries

## Introduction

There are a number of ways to optimize the queries that are generated by your Rails app. One way is to add indexes to the appropriate places. Another way to speed up your app is to optimize the queries that are auto-generated or hard-coded in your app.

## Indexes

As we discovered in chapters 8 and 9, adding indexes can significantly speed up the retrieval of data.

### Foreign Keys

When looking for ways to optimize our database, there are a number of places we can start. The first thing we should look for and add are indexes on all foreign keys.

Rails migrations by default add a primary key to a new table. PostgreSQL and MySQL automatically add indexes to these primary key fields. Foreign key indexes must be explicitly added to the database via a migration.

Joining tables is an expensive operation. Creating an index for a foreign key field allows the query optimizer to pull data from the index instead of having to perform a table scan, which is much faster.

### Partial Indexes

As the size of a table grows, creating specific indexes that are not only for a specific column, but an index that only contains a subset of the data can help make data retrieval more efficient because the index is smaller than the original table. Inserts and updates are also more efficient, because the partial index does not need to be updated every time a record is inserted or updated in the related table.

Partial indexes are indexes that have a WHERE clause. The WHERE clause is used to decide whether the index should be modified when a record is inserted, updated or deleted from the table. Regular indexes do not have a WHERE clause and are modifed for all changes on the table.

## Table Optimization

For databases that require regular maintenance, making sure that it's running lean is key to minimizing disk space usage and helping speed up queries that might need access tables directly.

## Inner joins vs left joins

## Common Table Expressions (CTE)

Sometimes business requirements dictate that data is aggregated for reporting purposes. Occasionally, that means that we would need to run multiple queries to generate the necessary output. Because ActiveRecord does not support returning multiple result sets, common table expressions can come to the rescue by allowing us to send a series of queries to the database in one statement and get a result set back. This also places the burden of aggregating data on the database server, reducing the need to pull back more data than is needed to display to the end user.

Common table expressions are written using the `WITH` clause. Each recordset is processed in order, and within the `WITH` clause the output from the previous query can be used in the next statement, and also used in the final `SELECT` statement.

Let's use the following table structure to write some common table expressions.

```sql
CREATE TABLE accounts (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  account_id INTEGER NOT NULL REFERENCES accounts (id),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  comment TEXT NOT NULL
);
```

Let's use these test values

```
INSERT INTO posts (account_id, created_at, comment)
VALUES (1, NOW(), 'short comment'), (2, NOW(), 'longer comment1'),
(3, NOW(), 'lonnnnnnnggggggger comment'), (3, NOW(), 'short comment'),
(5, NOW(), 'regular comment'), (5, NOW(), 'longest commmmmmenttttttttttttttt);

INSERT INTO accounts(name) VALUES ('test 1'), ('test 2'), ('test 3'), ('test 4'), ('test 5');
```

And finally, here's our CTE to retrieve the longest post (the length of the comments field) for each account_id

```sql
WITH post_lengths AS (
	SELECT account_id, MAX(LENGTH(posts.comment)) AS longest_post
	FROM posts
	GROUP BY account_id
)
SELECT posts.id, posts.account_id, posts.comment, LENGTH(posts.comment) AS post_length
FROM posts
JOIN post_lengths ON post_lengths.account_id = posts.account_id
WHERE LENGTH(posts.comment) = post_lengths.longest_post;
```

## Resources

* https://dev.mysql.com/doc/refman/8.0/en/with.html
* https://www.postgresql.org/docs/12/indexes-partial.html
* https://www.postgresql.org/docs/12/queries-with.html
* https://thoughtbot.com/blog/postgresql-performance-considerations

## Wrap-up
