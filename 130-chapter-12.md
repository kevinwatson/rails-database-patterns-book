### Chapter 12 - Indexes and Optimized Queries

## Introduction

There are a number of ways to optimize the queries that are generated by your Rails app. Optimizations can be peformed by fine-tuning the database server using our knowledge of the database schema.

## Indexes

As we discovered in chapters 8 and 9, adding indexes can significantly speed up the retrieval of data. Properly placed indexes can turn a slow running application into a high-performance system.

### Foreign Keys

When looking for ways to optimize our database, there are a number of places we can start. The first thing we should look for and add are indexes on all foreign keys.

Rails migrations by default add a primary key to a new table. PostgreSQL and MySQL automatically add indexes to these primary key fields. Foreign key indexes must be explicitly added to the database via a migration.

Joining tables is an expensive operation. Creating an index for a foreign key field allows the query optimizer to pull data from the index instead of having to perform a table scan, which is much faster.

### Partial Indexes

As the size of a table grows, creating specific indexes that are not only for a specific column, but an index that only contains a subset of the data can help make data retrieval more efficient because the index is smaller than the original table. Inserts and updates are also more efficient, because the partial index does not need to be updated every time a record is inserted or updated in the related table.

Partial indexes are indexes that have a WHERE clause. The WHERE clause is used to decide whether the index should be modified when a record is inserted, updated or deleted from the table. Regular indexes do not have a WHERE clause and are modifed for all changes on the table.

## Table Optimization

For databases that require regular maintenance, making sure that it's running lean is key to minimizing disk space usage and helping speed up queries that might need access tables directly.

## Inner Joins vs Left (Outer) Joins

When possible, favor inner joins over left joins. Left joins require that the database server first perform the work of an inner join, and then extend the result set with the values in the outer table that didn't match. Inner joins also return a smaller data set which requires less processing in the application.

## Common Table Expressions (CTE)

Sometimes business requirements dictate that data is aggregated for reporting purposes. Occasionally, that means that we would need to run multiple queries to generate the necessary output. Because ActiveRecord does not support multiple result sets, common table expressions can come to the rescue by allowing us to send a series of queries to the database in one statement and get a result set back. This also places the burden of aggregating data on the database server, reducing the need to pull back more data than is needed to display to the end user.

Common table expressions are written using the `WITH` clause. Each recordset is processed in order, and within the `WITH` clause the output from the previous query can be used in the next statement, and also used in the final `SELECT` statement.

Let's use the following table structure to write some common table expressions.

```sql
CREATE TABLE accounts (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  account_id INTEGER NOT NULL REFERENCES accounts (id),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  comment TEXT NOT NULL
);
```

Let's use these test values

```
INSERT INTO posts (account_id, created_at, comment)
VALUES (1, NOW(), 'short comment'),
(2, NOW(), 'longer comment'),
(3, NOW(), 'this is a longer comment'), (3, NOW(), 'short comment'),
(5, NOW(), 'regular comment'), (5, NOW(), 'this is definitely going to be the longest comment');

INSERT INTO accounts(name) VALUES ('test 1'), ('test 2'), ('test 3'), ('test 4'), ('test 5');
```

And finally, here's our CTE to retrieve the longest post (the length of the comments field) for each account_id

```sql
WITH post_lengths AS (
	SELECT account_id, MAX(LENGTH(posts.comment)) AS longest_post
	FROM posts
	GROUP BY account_id
)
SELECT posts.id, posts.account_id, posts.comment, LENGTH(posts.comment) AS post_length
FROM posts
JOIN post_lengths ON post_lengths.account_id = posts.account_id
WHERE LENGTH(posts.comment) = post_lengths.longest_post;
```

There are a number of ways to include a large, custom query like the one above in your code. Because CTEs are complex, we can construct the queries as a string and `execute` the queries in a single database call.

```ruby
def self.longest_posts
	sql = %{
		WITH post_lengths AS (
			SELECT account_id, MAX(LENGTH(posts.comment)) AS longest_post
			FROM posts
			GROUP BY account_id
		)
		SELECT posts.id, posts.account_id, posts.comment, LENGTH(posts.comment) AS post_length
		FROM posts
		JOIN post_lengths ON post_lengths.account_id = posts.account_id
		WHERE LENGTH(posts.comment) = post_lengths.longest_post
	}

	ActiveRecord::Base.connection.execute(sql)
end
```

## Resources

* https://dev.mysql.com/doc/refman/8.0/en/with.html
* https://dockyard.com/blog/2013/09/06/postgres_ext-adds-rank-and-common-table-expressions
* https://rubygems.org/gems/postgres_ext
* https://thoughtbot.com/blog/postgresql-performance-considerations
* https://www.postgresql.org/docs/12/indexes-partial.html
* https://www.postgresql.org/docs/12/queries-with.html

## Wrap-up

[Next >>](140-chapter-13.md)
